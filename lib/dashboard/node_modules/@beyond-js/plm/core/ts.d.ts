/************
 Processor: ts
 ************/

import * as dependency_0 from '@beyond-js/kernel/core/ts';

// FILE: auth/auth.d.ts
declare namespace ns_auth_auth {
    import Sessions = ns_auth_sessions.Sessions;
    const auth: {
        "__#24145@#sessions": Sessions;
        readonly sessions: Sessions;
        set(sessionName: string, accessToken: string): void;
    };
}

// FILE: auth/get-access-token.d.ts
declare namespace ns_auth_getaccesstoken {
    /**
     * Gets the session object from the session name
     *
     * @param session {string} The plm session name
     */
    function getAccessToken(session: string): Promise<string>;
}

// FILE: auth/session.d.ts
declare namespace ns_auth_session {
    import Events = dependency_0.Events;

    class PLMSession extends Events {
        #private;

        get name(): string;

        constructor(name: string);

        get accessToken(): string;
        set accessToken(value: string);
    }
}

// FILE: auth/sessions.d.ts
declare namespace ns_auth_sessions {
    import PLMSession = ns_auth_session.PLMSession;

    class Sessions extends Map<string, PLMSession> {
        register(name: string): PLMSession;

        unregister(name: string): void;
    }
}

// FILE: constants.d.ts
declare namespace ns_constants {
    const NotSet: {};

    enum DataSource {
        NotLoaded = 0,
        Cache = 1,
        Server = 2
    }
}

// FILE: elements/collection/collection.d.ts
declare namespace ns_elements_collection_collection {
    import Element = ns_elements_element.Element;
    import ElementSpecs = ns_elements_element.ElementSpecs;
    import ICollectionNodeSpecs = ns_tree_collection.ICollectionNodeSpecs;
    import CollectionNode = ns_tree_collection.CollectionNode;
    import ListData = ns_tables_data_lists_list.ListData;
    import CollectionCounters = ns_elements_collection_counters_counters.CollectionCounters;
    import Item = ns_elements_item_item.Item;
    import DerivedItem = ns_elements_item_item.DerivedItem;
    import FilterSpecs = ns_tables_data_filter_filter.FilterSpecs;
    import Tree = ns_elements_collection_tree.Tree;

    interface CollectionSpecs extends ElementSpecs {
        node?: CollectionNode;
        tree?: ICollectionNodeSpecs;
        filter?: FilterSpecs;
    }

    interface DerivedCollection {
        new(specs: CollectionSpecs): Collection;
    }

    class Collection extends Element<CollectionNode> {
        #private;

        get is(): string;

        get Item(): DerivedItem;

        get list(): ListData;

        get counters(): CollectionCounters;

        get items(): Item[];

        get tree(): Tree;

        /**
         * Loads the collection bringing the data from the local store cache
         *
         * @returns {Promise<void>}
         */
        load(tree?: boolean): Promise<void>;

        /**
         * Fetch the collection bringing the data from the server
         *
         * @param {boolean} tree Fetches the tree or only the current node
         * @returns {Promise<void>}
         */
        fetch(tree?: boolean): Promise<void>;

        /**
         * Loads or fetch data only if not data is already available
         *
         * @param {boolean} tree Fills the tree or only the current node
         * @returns {Promise<void>}
         */
        fill(tree?: boolean): Promise<void>;

        constructor(table: string, DItem: DerivedItem, specs: CollectionSpecs);

        destroy(): void;
    }
}

// FILE: elements/collection/counters/counter.d.ts
declare namespace ns_elements_collection_counters_counter {
    import Collection = ns_elements_collection_collection.Collection;
    import CounterData = ns_tables_data_counter_counter.CounterData;
    import FilterSpecs = ns_tables_data_filter_filter.FilterSpecs;

    class CollectionCounter {
        #private;

        get value(): CounterData;

        constructor(collection: Collection, name: string, conditions: FilterSpecs);

        load: () => Promise<void>;
        fetch: () => Promise<void>;

        activate(): void;

        deactivate(): void;
    }
}

// FILE: elements/collection/counters/counters.d.ts
declare namespace ns_elements_collection_counters_counters {
    import Collection = ns_elements_collection_collection.Collection;
    import CollectionCounter = ns_elements_collection_counters_counter.CollectionCounter;
    import FilterSpecs = ns_tables_data_filter_filter.FilterSpecs;

    class CollectionCounters extends Map<string, CollectionCounter> {
        #private;

        constructor(collection: Collection);

        register(name: string, conditions?: FilterSpecs): void;

        load(): Promise<void>;

        fetch(): Promise<void>;

        fill(): Promise<void>;
    }
}

// FILE: elements/collection/items/items.d.ts
declare namespace ns_elements_collection_items_items {
    import Collection = ns_elements_collection_collection.Collection;
    import Item = ns_elements_item_item.Item;

    class CollectionItems {
        #private;

        get items(): Item[];

        constructor(collection: Collection);

        update: () => void;

        load(): Promise<void>;

        fetch(): Promise<void>;

        fill(): Promise<void>;

        activate(): void;

        destroy(): void;
    }
}

// FILE: elements/collection/tree.d.ts
declare namespace ns_elements_collection_tree {
    import Collection = ns_elements_collection_collection.Collection;

    class Tree {
        #private;

        constructor(collection: Collection);

        get landed(): boolean;
    }
}

// FILE: elements/element.d.ts
declare namespace ns_elements_element {
    import Table = ns_tables_table.Table;
    import Node = ns_tree_node.Node;
    import ListenerFunction = dependency_0.ListenerFunction;
    import Product = ns_tables_data_factory_product.Product;

    interface ElementSpecs {
        session?: string;
    }

    interface Element<NODE extends Node> {
        is: string;

        load(tree?: boolean): Promise<void>;

        fetch(tree?: boolean): Promise<void>;

        fill(tree?: boolean): Promise<void>;
    }

    abstract class Element<NODE extends Node> {
        #private;
        on: (event: string, listener: ListenerFunction, priority?: number) => NODE;
        bind: (event: string, listener: ListenerFunction, priority?: number) => NODE;
        off: (event: string, listener: ListenerFunction) => NODE;
        unbind: (event: string, listener: ListenerFunction) => NODE;

        get node(): NODE;
        set node(value: NODE);

        get active(): boolean;
        set active(value: boolean);

        get data(): Product;
        set data(value: Product);

        get session(): string;

        get table(): Table;

        get loaded(): boolean;

        get fetching(): boolean;

        get fetched(): boolean;

        get landed(): boolean;

        restore(): Promise<void>;

        protected constructor(table: string);

        destroy(): void;
    }
}

// FILE: elements/item/fields/field.d.ts
declare namespace ns_elements_item_fields_field {
    import Item = ns_elements_item_item.Item;

    class ItemField {
        #private;

        constructor(item: Item, name: string);

        get assigned(): boolean;

        get value(): any;
        set value(value: any);
    }
}

// FILE: elements/item/fields/fields.d.ts
declare namespace ns_elements_item_fields_fields {
    import Item = ns_elements_item_item.Item;
    import ItemField = ns_elements_item_fields_field.ItemField;

    class ItemFields extends Map<string, ItemField> {
        constructor(item: Item);
    }
}

// FILE: elements/item/item.d.ts
declare namespace ns_elements_item_item {
    import Element = ns_elements_element.Element;
    import ElementSpecs = ns_elements_element.ElementSpecs;
    import ItemNodeSpecs = ns_tree_item.ItemNodeSpecs;
    import ItemNode = ns_tree_item.ItemNode;
    import RecordIdentifier = ns_tables_data_records_data_record.RecordIdentifier;
    import Properties = ns_elements_item_properties_properties.Properties;
    import WrappedRecord = ns_tables_data_records_wrapped_record.WrappedRecord;
    import ItemFields = ns_elements_item_fields_fields.ItemFields;
    import Tree = ns_elements_item_tree.Tree;

    interface ItemSpecs extends ElementSpecs {
        tree?: ItemNodeSpecs;
        node?: ItemNode;
        identifier?: RecordIdentifier;
        pk?: (string | number);
        localId?: string;
    }

    interface DerivedItem {
        new(specs: ItemSpecs): Item;
    }

    class Item extends Element<ItemNode> {
        #private;

        get is(): string;

        get record(): WrappedRecord;

        get version(): number;

        get fields(): ItemFields;

        get properties(): Properties;

        get loaded(): boolean;

        get fetched(): boolean;

        get fetching(): boolean;

        get found(): boolean;

        get tree(): Tree;

        load(tree?: boolean): Promise<void>;

        fetch(tree?: boolean): Promise<void>;

        fill(tree?: boolean): Promise<void>;

        constructor(table: string, specs: ItemSpecs);

        destroy(): void;
    }
}

// FILE: elements/item/properties/collection/filter.d.ts
declare namespace ns_elements_item_properties_collection_filter {
    import FilterSpecs = ns_tables_data_filter_filter.FilterSpecs;
    import CollectionNode = ns_tree_collection.CollectionNode;
    import Item = ns_elements_item_item.Item;

    class CollectionPropertyFilter {
        #private;

        get value(): FilterSpecs;

        get valid(): boolean;

        /**
         * CollectionPropertyFilter Constructor
         *
         * @param {Item} item
         * @param {ItemNode} node
         */
        constructor(item: Item, node: CollectionNode);

        /**
         * Generates the identifier of the item to be created
         */
        update(): void;
    }
}

// FILE: elements/item/properties/collection/property.d.ts
declare namespace ns_elements_item_properties_collection_property {
    import Item = ns_elements_item_item.Item;
    import Collection = ns_elements_collection_collection.Collection;
    import CollectionPropertyFilter = ns_elements_item_properties_collection_filter.CollectionPropertyFilter;
    import CollectionNode = ns_tree_collection.CollectionNode;
    import Property = ns_elements_item_properties_property.Property;
    import Tree = ns_elements_item_properties_collection_tree.Tree;

    class CollectionProperty implements Property {
        #private;

        get is(): string;

        get node(): CollectionNode;

        readonly tree: Tree;

        get value(): Collection;

        get filter(): CollectionPropertyFilter;

        constructor(parentItem: Item, node: CollectionNode);

        update(): Collection;

        load: () => Promise<void>;
        fetch: () => Promise<void>;
        fill: () => Promise<void>;
        destroy: () => void;
    }
}

// FILE: elements/item/properties/collection/tree.d.ts
declare namespace ns_elements_item_properties_collection_tree {
    import CollectionProperty = ns_elements_item_properties_collection_property.CollectionProperty;

    class Tree {
        #private;

        constructor(property: CollectionProperty);

        get landed(): boolean;
    }
}

// FILE: elements/item/properties/item-selector/property.d.ts
declare namespace ns_elements_item_properties_itemselector_property {
    import Property = ns_elements_item_properties_property.Property;
    import Item = ns_elements_item_item.Item;
    import ItemPropertyIdentifier = ns_elements_item_properties_item_identifier.ItemPropertyIdentifier;
    import ItemSelectorNode = ns_tree_itemselector.ItemSelectorNode;
    import Tree = ns_elements_item_properties_itemselector_tree.Tree;

    class ItemSelectorProperty implements Property {
        #private;

        get is(): string;

        get node(): ItemSelectorNode;

        readonly tree: Tree;

        get value(): Item;

        get identifier(): ItemPropertyIdentifier;

        constructor(parentItem: Item, node: ItemSelectorNode);

        update(): Item;

        load: () => Promise<void>;
        fetch: () => Promise<void>;
        fill: () => Promise<void>;
        destroy: () => void;
    }
}

// FILE: elements/item/properties/item-selector/tree.d.ts
declare namespace ns_elements_item_properties_itemselector_tree {
    import ItemSelectorProperty = ns_elements_item_properties_itemselector_property.ItemSelectorProperty;

    class Tree {
        #private;

        constructor(property: ItemSelectorProperty);

        get landed(): boolean;
    }
}

// FILE: elements/item/properties/item/identifier.d.ts
declare namespace ns_elements_item_properties_item_identifier {
    import ItemNode = ns_tree_item.ItemNode;
    import Item = ns_elements_item_item.Item;
    import RecordIdentifier = ns_tables_data_records_data_record.RecordIdentifier;

    class ItemPropertyIdentifier {
        #private;

        get value(): RecordIdentifier;

        get valid(): boolean;

        /**
         * ItemPropertyIdentifier Constructor
         *
         * @param {Item} item
         * @param {ItemNode} node
         */
        constructor(item: Item, node: ItemNode);

        /**
         * Generates the identifier of the item to be created
         */
        update(): void;
    }
}

// FILE: elements/item/properties/item/property.d.ts
declare namespace ns_elements_item_properties_item_property {
    import Item = ns_elements_item_item.Item;
    import ItemNode = ns_tree_item.ItemNode;
    import ItemPropertyIdentifier = ns_elements_item_properties_item_identifier.ItemPropertyIdentifier;
    import Property = ns_elements_item_properties_property.Property;
    import Tree = ns_elements_item_properties_item_tree.Tree;

    class ItemProperty implements Property {
        #private;

        get is(): string;

        get node(): ItemNode;

        readonly tree: Tree;

        get value(): Item;

        get identifier(): ItemPropertyIdentifier;

        constructor(parentItem: Item, node: ItemNode);

        update(): Item;

        load: () => Promise<void>;
        fetch: () => Promise<void>;
        fill: () => Promise<void>;
        destroy: () => void;
    }
}

// FILE: elements/item/properties/item/tree.d.ts
declare namespace ns_elements_item_properties_item_tree {
    import ItemProperty = ns_elements_item_properties_item_property.ItemProperty;

    class Tree {
        #private;

        constructor(property: ItemProperty);

        get landed(): boolean;
    }
}

// FILE: elements/item/properties/items/property.d.ts
declare namespace ns_elements_item_properties_items_property {
    import Property = ns_elements_item_properties_property.Property;
    import Item = ns_elements_item_item.Item;
    import ItemsNode = ns_tree_items.ItemsNode;
    import Tree = ns_elements_item_properties_items_tree.Tree;

    class ItemsProperty extends Map implements Property {
        #private;

        get is(): string;

        get node(): ItemsNode;

        readonly tree: Tree;

        constructor(parentItem: Item, node: ItemsNode);

        update(): this;

        load(): Promise<void>;

        push(value: string | number): void;

        delete(id: string | number): boolean;

        fetch(): Promise<void>;

        fill(): Promise<void>;

        destroy(): void;
    }
}

// FILE: elements/item/properties/items/tree.d.ts
declare namespace ns_elements_item_properties_items_tree {
    import ItemsProperty = ns_elements_item_properties_items_property.ItemsProperty;

    class Tree {
        #private;

        constructor(property: ItemsProperty);

        get landed(): boolean;
    }
}

// FILE: elements/item/properties/properties.d.ts
declare namespace ns_elements_item_properties_properties {
    import Item = ns_elements_item_item.Item;
    import Property = ns_elements_item_properties_property.Property;

    class Properties extends Map<string, Property> {
        constructor(item: Item);

        load: () => void;
        fetch: () => void;
        fill: () => void;
        update: () => void;
    }
}

// FILE: elements/item/properties/property.d.ts
declare namespace ns_elements_item_properties_property {
    interface Property {
        load: () => void;
        fetch: () => void;
        update: () => void;
        fill: () => void;
        tree: {
            landed: boolean;
        };
    }
}

// FILE: elements/item/tree.d.ts
declare namespace ns_elements_item_tree {
    import Item = ns_elements_item_item.Item;

    class Tree {
        #private;

        constructor(item: Item);

        get landed(): boolean;
    }
}

// FILE: elements/realtime.d.ts
declare namespace ns_elements_realtime {
    import Element = ns_elements_element.Element;

    class Realtime {
        #private;

        constructor(element: Element<any>);

        destroy(): void;
    }
}

// FILE: tables/data/counter/counter.d.ts
declare namespace ns_tables_data_counter_counter {
    import Product = ns_tables_data_factory_product.Product;
    import CountersManager = ns_tables_data_counter_manager.CountersManager;
    import FilterSpecs = ns_tables_data_filter_filter.FilterSpecs;
    import Filter = ns_tables_data_filter_filter.Filter;
    import CounterLocalStore = ns_tables_data_counter_localstore.CounterLocalStore;
    type CounterAttributes = Record<string, any>;

    interface Value {
        value: number;
    }

    class CounterData extends Product {
        #private;

        get filter(): Filter;

        get attributes(): CounterAttributes;

        get value(): number;

        get localStore(): CounterLocalStore;

        get loaded(): boolean;

        load(): Promise<void>;

        get fetching(): boolean;

        get fetched(): boolean;

        fetch(): Promise<void>;

        constructor(manager: CountersManager, key: string, instanceId: number, filterSpecs: FilterSpecs, attributes: CounterAttributes, session: string);
    }
}

// FILE: tables/data/counter/fetch.d.ts
declare namespace ns_tables_data_counter_fetch {
    import CounterData = ns_tables_data_counter_counter.CounterData;
    import Value = ns_tables_data_counter_counter.Value;

    class CounterFetch {
        #private;

        constructor(counter: CounterData, value: Value);

        get fetching(): boolean;

        get fetched(): boolean;

        fetch(): Promise<void>;
    }
}

// FILE: tables/data/counter/local-store.d.ts
declare namespace ns_tables_data_counter_localstore {
    import CounterData = ns_tables_data_counter_counter.CounterData;

    class CounterLocalStore {
        #private;

        get loaded(): boolean;

        load(): Promise<number>;

        constructor(counter: CounterData);
    }
}

// FILE: tables/data/counter/manager.d.ts
declare namespace ns_tables_data_counter_manager {
    import CounterAttributes = ns_tables_data_counter_counter.CounterAttributes;
    import CounterData = ns_tables_data_counter_counter.CounterData;
    import Factory = ns_tables_data_factory_factory.Factory;
    import FilterSpecs = ns_tables_data_filter_filter.FilterSpecs;

    class CountersManager extends Factory<CounterData> {
        protected create(key: string, instanceId: number, filter: FilterSpecs, attributes: CounterAttributes, session: string): CounterData;

        get(filter: FilterSpecs, attributes: CounterAttributes, session: string): CounterData;
    }
}

// FILE: tables/data/factory/compare-objects.d.ts
declare namespace ns_tables_data_factory_compareobjects {
    class CompareObjects {
        static generate(...any: any): string;

        static compare(i1: any, i2: any): boolean;
    }
}

// FILE: tables/data/factory/factory.d.ts
declare namespace ns_tables_data_factory_factory {
    import Events = dependency_0.Events;
    import Table = ns_tables_table.Table;
    import Product = ns_tables_data_factory_product.Product;

    abstract class Factory<PRODUCT extends Product> extends Events {
        #private;

        get table(): Table;

        constructor(table: Table);

        has(...any: any[]): boolean;

        protected abstract create(...any: any[]): PRODUCT;

        get(...any: any[]): PRODUCT;

        hold(instanceId: number): void;

        /**
         * Release a product from being consumed. Many consumers can hold the same product, so only destroy it
         * when no consumers are holding it
         *
         * @param {number} instanceId The instance id of the product
         * @returns {Product} Returns the product only if it has been destroyed
         */
        release(instanceId: number): Product;
    }
}

// FILE: tables/data/factory/product.d.ts
declare namespace ns_tables_data_factory_product {
    import Events = dependency_0.Events;
    import Factory = ns_tables_data_factory_factory.Factory;

    abstract class Product extends Events {
        #private;

        get manager(): Factory<any>;

        get table(): ns_tables_table.Table;

        get key(): string;

        get instanceId(): number;

        get session(): string;

        hold(): void;

        release(): void;

        abstract get loaded(): boolean;

        abstract get fetched(): boolean;

        abstract get fetching(): boolean;

        get landed(): boolean;

        abstract load(): void;

        abstract fetch(): void;

        /**
         * Product Constructor
         * @param {Factory<*>} manager The manager of the product (instance of a factory)
         * @param {string} key The key generated by CompareObjects.generate(filter, attributes, session)
         * @param {number} instanceId The auto-numeric instance id generated by the manager
         * @param {string} session The session name
         * @protected
         */
        protected constructor(manager: Factory<any>, key: string, instanceId: number, session: string);
    }
}

// FILE: tables/data/filter/filter.d.ts
declare namespace ns_tables_data_filter_filter {
    import Table = ns_tables_table.Table;
    import RecordData = ns_tables_data_records_data_record.RecordData;

    enum ConditionOperand {
        Equal = 0,
        Greater = 1,
        GreaterOrEqual = 2,
        Lower = 3,
        LowerOrEqual = 4
    }

    type Condition = {
        field: string;
        operand: ConditionOperand;
        value: string | number | boolean;
    };
    type FilterSpecs = Condition[];

    class Filter {
        #private;

        get table(): Table;

        get specs(): FilterSpecs;

        get fields(): Set<string>;

        /**
         * Checks if the record should be included in the list or not
         * @param {RecordData} record
         */
        applies(record: RecordData): boolean;

        constructor(table: Table, specs: FilterSpecs);
    }
}

// FILE: tables/data/lists/fetch.d.ts
declare namespace ns_tables_data_lists_fetch {
    import ListData = ns_tables_data_lists_list.ListData;

    class ListFetch {
        #private;

        constructor(list: ListData);

        get fetching(): boolean;

        get fetched(): boolean;

        fetch(): Promise<void>;
    }
}

// FILE: tables/data/lists/list.d.ts
declare namespace ns_tables_data_lists_list {
    import Product = ns_tables_data_factory_product.Product;
    import ListsManager = ns_tables_data_lists_manager_manager.ListsManager;
    import FilterSpecs = ns_tables_data_filter_filter.FilterSpecs;
    import Filter = ns_tables_data_filter_filter.Filter;
    import ListLocalStore = ns_tables_data_lists_localstore.ListLocalStore;
    import ListRecords = ns_tables_data_lists_records.ListRecords;
    import Order = ns_tables_data_lists_order.Order;
    import OrderSpecs = ns_tables_data_lists_order.OrderSpecs;
    type ListAttributes = Record<string, any>;

    class ListData extends Product {
        #private;

        get filter(): Filter;

        get order(): Order;

        get attributes(): ListAttributes;

        invalidate(): void;

        get records(): ListRecords;

        get localStore(): ListLocalStore;

        get loaded(): boolean;

        load(): Promise<void>;

        get fetching(): boolean;

        get fetched(): boolean;

        fetch(): Promise<void>;

        /**
         * ListData Constructor
         * @param {ListsManager} manager The manager of the list (instance of a factory)
         * @param {string} key The key generated by CompareObjects.generate(filter, attributes, session)
         * @param {number} instanceId The auto-numeric instance id generated by the manager
         * @param {FilterSpecs} filterSpecs The filter specification
         * @param {OrderSpecs} orderSpecs The order specification
         * @param {ListAttributes} attributes The attributes of the list
         * @param {string} session The session name
         */
        constructor(manager: ListsManager, key: string, instanceId: number, filterSpecs: FilterSpecs, orderSpecs: OrderSpecs, attributes: ListAttributes, session: string);

        destroy(): void;
    }
}

// FILE: tables/data/lists/local-store.d.ts
declare namespace ns_tables_data_lists_localstore {
    import ListData = ns_tables_data_lists_list.ListData;
    import IdsList = ns_tables_localdatabase_lists_lists.IdsList;

    class ListLocalStore {
        #private;

        get loaded(): boolean;

        load(): Promise<IdsList>;

        constructor(list: ListData);
    }
}

// FILE: tables/data/lists/manager/manager.d.ts
declare namespace ns_tables_data_lists_manager_manager {
    import ListAttributes = ns_tables_data_lists_list.ListAttributes;
    import ListData = ns_tables_data_lists_list.ListData;
    import FilterSpecs = ns_tables_data_filter_filter.FilterSpecs;
    import Factory = ns_tables_data_factory_factory.Factory;
    import OrderSpecs = ns_tables_data_lists_order.OrderSpecs;
    import Registries = ns_tables_data_lists_manager_registries_registries.Registries;
    import Realtime = ns_tables_data_lists_manager_realtime_realtime.Realtime;

    class ListsManager extends Factory<ListData> {
        #private;

        get registries(): Registries;

        get realtime(): Realtime;

        protected create(key: string, instanceId: number, filter: FilterSpecs, order: OrderSpecs, attributes: ListAttributes, session: string): ListData;

        get(filter: FilterSpecs, order: OrderSpecs, attributes: ListAttributes, session: string): ListData;

        release(instanceId: number): ListData;
    }
}

// FILE: tables/data/lists/manager/realtime/realtime.d.ts
declare namespace ns_tables_data_lists_manager_realtime_realtime {
    import ListsManager = ns_tables_data_lists_manager_manager.ListsManager;
    import Reports = ns_tables_data_lists_manager_realtime_reports.Reports;

    class Realtime {
        #private;

        get reports(): Reports;

        constructor(manager: ListsManager);
    }
}

// FILE: tables/data/lists/manager/realtime/reports.d.ts
declare namespace ns_tables_data_lists_manager_realtime_reports {
    import ListsManager = ns_tables_data_lists_manager_manager.ListsManager;
    import ListUpdateFilterReport = ns_tables_data_realtime_reports_list.ListUpdateFilterReport;

    class Reports {
        #private;

        constructor(manager: ListsManager);

        update(filter: ListUpdateFilterReport): void;
    }
}

// FILE: tables/data/lists/manager/registries/filter.d.ts
declare namespace ns_tables_data_lists_manager_registries_filter {
    import ListData = ns_tables_data_lists_list.ListData;
    import ListsRegistry = ns_tables_data_lists_manager_registries_registries.ListsRegistry;
    import Filter = ns_tables_data_filter_filter.Filter;

    interface ListsByFilter {
        filter: Filter;
        lists: ListData[];
    }

    class RegistryByFilter extends Map<string, ListsByFilter> implements ListsRegistry {
        informListCreated(list: ListData): void;

        informListDestroyed(list: ListData): void;
    }
}

// FILE: tables/data/lists/manager/registries/registries.d.ts
declare namespace ns_tables_data_lists_manager_registries_registries {
    import ListData = ns_tables_data_lists_list.ListData;
    import ListsManager = ns_tables_data_lists_manager_manager.ListsManager;
    import RegistryByFilter = ns_tables_data_lists_manager_registries_filter.RegistryByFilter;

    interface ListsRegistry {
        informListCreated: (list: ListData) => void;
        informListDestroyed: (list: ListData) => void;
    }

    class Registries {
        #private;

        constructor(manager: ListsManager);

        get filters(): RegistryByFilter;

        informListCreated(list: ListData): void;

        informListDestroyed(list: ListData): void;
    }
}

// FILE: tables/data/lists/order.d.ts
declare namespace ns_tables_data_lists_order {
    import Table = ns_tables_table.Table;

    interface FieldOrderSpecs {
        field: string;
        asc: boolean;
    }

    type OrderSpecs = FieldOrderSpecs[];

    class Order {
        #private;

        get table(): Table;

        get specs(): OrderSpecs;

        constructor(table: Table, specs: OrderSpecs);
    }
}

// FILE: tables/data/lists/records.d.ts
declare namespace ns_tables_data_lists_records {
    import ListData = ns_tables_data_lists_list.ListData;
    type RecordId = {
        unpublished: boolean;
        localId?: string;
        pk?: (string | number);
    };

    class ListRecords {
        #private;

        get list(): ListData;

        get values(): RecordId[];

        /**
         * ListRecords Constructor
         * @param {ListRecords} list
         */
        constructor(list: ListData);

        destroy(): void;

        overwrite(values: (string | number)[]): void;
    }
}

// FILE: tables/data/realtime/realtime.d.ts
declare namespace ns_tables_data_realtime_realtime {
    import Reports = ns_tables_data_realtime_reports_reports.Reports;
    const realtime: {
        "__#24225@#reports": Reports;
        readonly reports: Reports;
    };
}

// FILE: tables/data/realtime/reports/list.d.ts
declare namespace ns_tables_data_realtime_reports_list {
    type ListUpdateFilterReport = Record<string, string | number | boolean>;

    class ListReport {
        update(tableName: string, filter: ListUpdateFilterReport): void;
    }
}

// FILE: tables/data/realtime/reports/record.d.ts
declare namespace ns_tables_data_realtime_reports_record {
    interface RecordUpdateFilterReport {
        field: string;
        value: string | number | boolean;
    }

    class RecordReport {
        #private;

        insert(tableName: string, id: string | number): void;

        delete(tableName: string, id: string | number): void;

        update(tableName: string, pk: string | number): void;
    }
}

// FILE: tables/data/realtime/reports/reports.d.ts
declare namespace ns_tables_data_realtime_reports_reports {
    import RecordReport = ns_tables_data_realtime_reports_record.RecordReport;
    import ListReport = ns_tables_data_realtime_reports_list.ListReport;

    class Reports {
        #private;

        get list(): ListReport;

        get record(): RecordReport;
    }
}

// FILE: tables/data/records/data/factory.d.ts
declare namespace ns_tables_data_records_data_factory {
    import Events = dependency_0.Events;
    import Table = ns_tables_table.Table;
    import RecordData = ns_tables_data_records_data_record.RecordData;
    import RecordIdentifier = ns_tables_data_records_data_record.RecordIdentifier;
    import UnpublishedRecords = ns_tables_data_records_data_unpublished.UnpublishedRecords;
    import WrappedFactory = ns_tables_data_records_wrapped_factory.WrappedFactory;

    class RecordsDataFactory extends Events {
        #private;

        get table(): Table;

        get unpublished(): UnpublishedRecords;

        constructor(table: Table);

        set wrappedFactory(value: WrappedFactory);

        get(identifier: RecordIdentifier, session: string): RecordData;

        /**
         * This method is called by the wrapped record.
         * When an identifier is not longer used (no consumers are holding the identifier),
         * then the wrapped record is destroyed, and this method is called.
         * It is required to check if there still are other identifiers using this record before destroying it.
         *
         * @param {RecordIdentifier} identifier
         * @param {string} session
         */
        release(identifier: RecordIdentifier, session: string): void;

        create: (session: string) => RecordData;
        getUnpublished: (localId: string) => RecordData;
    }
}

// FILE: tables/data/records/data/fetcher.d.ts
declare namespace ns_tables_data_records_data_fetcher {
    import RecordData = ns_tables_data_records_data_record.RecordData;
    import RecordDataVersion = ns_tables_data_records_data_record.RecordDataVersion;

    class RecordFetcher {
        #private;

        constructor(record: RecordData, version: RecordDataVersion);

        get fetching(): boolean;

        get fetched(): boolean;

        fetch(): Promise<boolean>;
    }
}

// FILE: tables/data/records/data/fields/field.d.ts
declare namespace ns_tables_data_records_data_fields_field {
    import RecordData = ns_tables_data_records_data_record.RecordData;
    import PublishedFieldSource = ns_tables_data_records_data_fields_sources_published.PublishedFieldSource;

    class Field {
        #private;

        get name(): string;

        get record(): RecordData;

        get memory(): any;

        get published(): PublishedFieldSource;

        /**
         * Field Constructor
         *
         * @param name {string} The name of the field
         * @param record {object} The Record instance
         */
        constructor(name: string, record: RecordData);

        get value(): any;

        /**
         * true if any of the sources (memory or published) has a value different than [NotSet, undefined] or
         * true is returned if the initial identifier is set for this field
         * @returns {boolean}
         */
        get assigned(): boolean;

        get unpublished(): boolean;

        discard: () => void;
    }
}

// FILE: tables/data/records/data/fields/fields.d.ts
declare namespace ns_tables_data_records_data_fields_fields {
    import RecordData = ns_tables_data_records_data_record.RecordData;
    import Field = ns_tables_data_records_data_fields_field.Field;
    import FieldsSetter = ns_tables_data_records_data_fields_setter.FieldsSetter;

    /**
     * The record fields
     */
    class Fields extends Map<string, Field> {
        #private;

        get record(): RecordData;

        get setter(): FieldsSetter;

        constructor(record: RecordData);

        /**
         * If any of the fields have a published value assigned, it means that the
         * record is already back-end persisted
         * @returns {boolean}
         */
        get persisted(): boolean;

        /**
         * Returns an object with the key-value of the unpublished fields
         */
        unpublished(): Map<string, Field>;

        discard: () => void;
    }
}

// FILE: tables/data/records/data/fields/setter.d.ts
declare namespace ns_tables_data_records_data_fields_setter {
    import RecordFieldsValues = ns_tables_localdatabase_records_records.RecordFieldsValues;
    import RecordData = ns_tables_data_records_data_record.RecordData;

    class FieldsSetter {
        #private;

        constructor(record: RecordData);

        values(values: RecordFieldsValues): void;
    }
}

// FILE: tables/data/records/data/fields/sources/memory.d.ts
declare namespace ns_tables_data_records_data_fields_sources_memory {
    import FieldSource = ns_tables_data_records_data_fields_sources_source.FieldSource;
    import Field = ns_tables_data_records_data_fields_field.Field;

    class MemoryFieldSource extends FieldSource {
        constructor(field: Field);
    }
}

// FILE: tables/data/records/data/fields/sources/published.d.ts
declare namespace ns_tables_data_records_data_fields_sources_published {
    import FieldSource = ns_tables_data_records_data_fields_sources_source.FieldSource;
    import Field = ns_tables_data_records_data_fields_field.Field;

    class PublishedFieldSource extends FieldSource {
        constructor(field: Field);
    }
}

// FILE: tables/data/records/data/fields/sources/source.d.ts
declare namespace ns_tables_data_records_data_fields_sources_source {
    import Field = ns_tables_data_records_data_fields_field.Field;

    interface FieldSourceSpecs {
        modifiable?: boolean;
    }

    /**
     * FieldSource instances are the memory and published properties of each record field
     */
    class FieldSource {
        #private;

        protected get field(): Field;

        get value(): any;
        set value(value: any);

        get assigned(): boolean;

        constructor(field: Field, specs?: FieldSourceSpecs);

        /**
         * Set the value of the field directly, without triggering events nor making any validation,
         * it is used internally by plm, .. consumers should not use it
         */
        overwrite(value: any): void;

        discard(): void;
    }
}

// FILE: tables/data/records/data/identifiers.d.ts
declare namespace ns_tables_data_records_data_identifiers {
    import Events = dependency_0.Events;
    import RecordData = ns_tables_data_records_data_record.RecordData;
    import RecordIdentifier = ns_tables_data_records_data_record.RecordIdentifier;
    import Index = ns_tables_indices_index.Index;

    class RecordIdentifiers extends Events {
        #private;

        get initial(): RecordIdentifier;

        get size(): number;

        errors(): string[];

        get(indexName: string): RecordIdentifier;

        /**
         * RecordIdentifiers Constructor
         *
         * @param {RecordData} record
         * @param {RecordIdentifier} initial The initial identifier when the record was created by the manager
         */
        constructor(record: RecordData, initial?: RecordIdentifier);

        get primaryKeyFieldValue(): any;

        /**
         * Finds the index that fits an identifier
         *
         * @param {RecordIdentifier} identifier
         * @returns {Index | undefined}
         */
        getIndex: (identifier: RecordIdentifier) => Index;

        /**
         * Returns an identifier according to the fields of an index
         *
         * @param {string} indexName
         * @returns {RecordIdentifier | undefined}
         */
        createIdentifierFromIndex(indexName: string): RecordIdentifier;

        /**
         * Updates the identifiers according to the values of the fields of the record
         */
        update(): void;

        forEach: (callback: any) => void;

        [Symbol.iterator](): Generator<RecordIdentifier, void, unknown>;
    }
}

// FILE: tables/data/records/data/loader.d.ts
declare namespace ns_tables_data_records_data_loader {
    import RecordData = ns_tables_data_records_data_record.RecordData;
    import RecordDataVersion = ns_tables_data_records_data_record.RecordDataVersion;

    class RecordLoader {
        #private;

        constructor(record: RecordData, version: RecordDataVersion);

        get loaded(): boolean;

        get searched(): boolean;

        load(): Promise<boolean>;
    }
}

// FILE: tables/data/records/data/record.d.ts
declare namespace ns_tables_data_records_data_record {
    import Events = dependency_0.Events;
    import Fields = ns_tables_data_records_data_fields_fields.Fields;
    import RecordIdentifiers = ns_tables_data_records_data_identifiers.RecordIdentifiers;
    import RecordLoader = ns_tables_data_records_data_loader.RecordLoader;
    import RecordsDataFactory = ns_tables_data_records_data_factory.RecordsDataFactory;
    import Field = ns_tables_data_records_data_fields_field.Field;
    type RecordIdentifier = Record<string, string | number | boolean>;

    interface RecordDataVersion {
        value?: number;
    }

    class RecordData extends Events {
        #private;

        get manager(): RecordsDataFactory;

        get table(): ns_tables_table.Table;

        get fields(): Fields;

        get identifiers(): RecordIdentifiers;

        get localId(): string;

        get version(): number;

        get loader(): RecordLoader;

        get loaded(): boolean;

        load(): Promise<void>;

        get fetching(): boolean;

        get fetched(): boolean;

        get landed(): boolean;

        get found(): boolean;

        fetch(): Promise<void>;

        /**
         * The record is expected to be back-end persisted when:
         *   . At least an identifier is set, example: if it was created a user with
         *   an identifier by its "nickname" = "..". In this case it is expected that the record
         *   was instantiated to be loaded
         *   . When the primary key is set
         * @returns {boolean}
         */
        get persisted(): boolean;

        /**
         * Returns the primary key field
         * @returns {*} the value
         */
        get pk(): Field;

        invalidate(): void;

        /**
         * RecordData Constructor
         * @param {RecordsDataFactory} manager
         * @param {string | RecordIdentifier} identifier Can be the localId (string)
         * or the initial identifier (RecordIdentifier)
         * @param {string} session
         */
        constructor(manager: RecordsDataFactory, identifier: string | RecordIdentifier, session?: string);

        destroy(): void;
    }
}

// FILE: tables/data/records/data/unpublished.d.ts
declare namespace ns_tables_data_records_data_unpublished {
    import RecordData = ns_tables_data_records_data_record.RecordData;
    import RecordsDataFactory = ns_tables_data_records_data_factory.RecordsDataFactory;

    class UnpublishedRecords {
        #private;

        constructor(recordsDataFactory: RecordsDataFactory);

        create(session: string): RecordData;

        getUnpublished(localId: string): RecordData;
    }
}

// FILE: tables/data/records/manager.d.ts
declare namespace ns_tables_data_records_manager {
    import Events = dependency_0.Events;
    import Table = ns_tables_table.Table;
    import RecordsDataFactory = ns_tables_data_records_data_factory.RecordsDataFactory;
    import RecordData = ns_tables_data_records_data_record.RecordData;
    import RecordIdentifier = ns_tables_data_records_data_record.RecordIdentifier;
    import WrappedRecord = ns_tables_data_records_wrapped_record.WrappedRecord;
    import UnpublishedRecords = ns_tables_data_records_data_unpublished.UnpublishedRecords;
    import Realtime = ns_tables_data_records_realtime_realtime.Realtime;

    class RecordsManager extends Events {
        #private;

        get recordsDataFactory(): RecordsDataFactory;

        get table(): Table;

        get unpublished(): UnpublishedRecords;

        get realtime(): Realtime;

        constructor(table: Table);

        get(identifier: RecordIdentifier, session: string): WrappedRecord;

        create(session: string): RecordData;

        getUnpublished(localId: string): RecordData;
    }
}

// FILE: tables/data/records/realtime/realtime.d.ts
declare namespace ns_tables_data_records_realtime_realtime {
    import RecordsManager = ns_tables_data_records_manager.RecordsManager;
    import Reports = ns_tables_data_records_realtime_reports.Reports;

    class Realtime {
        #private;

        get reports(): Reports;

        constructor(manager: RecordsManager);
    }
}

// FILE: tables/data/records/realtime/reports.d.ts
declare namespace ns_tables_data_records_realtime_reports {
    import RecordsManager = ns_tables_data_records_manager.RecordsManager;

    class Reports {
        #private;

        constructor(manager: RecordsManager);

        update(pk: string | number): void;
    }
}

// FILE: tables/data/records/wrapped/factory.d.ts
declare namespace ns_tables_data_records_wrapped_factory {
    import Factory = ns_tables_data_factory_factory.Factory;
    import WrappedRecord = ns_tables_data_records_wrapped_record.WrappedRecord;
    import Table = ns_tables_table.Table;
    import RecordsDataFactory = ns_tables_data_records_data_factory.RecordsDataFactory;
    import RecordIdentifier = ns_tables_data_records_data_record.RecordIdentifier;

    class WrappedFactory extends Factory<WrappedRecord> {
        #private;

        get recordsDataFactory(): RecordsDataFactory;

        constructor(table: Table, recordsDataFactory: RecordsDataFactory);

        protected create(key: string, instanceId: number, identifier: RecordIdentifier, session: string): WrappedRecord;

        get(identifier: RecordIdentifier, session: string): WrappedRecord;
    }
}

// FILE: tables/data/records/wrapped/fields/field.d.ts
declare namespace ns_tables_data_records_wrapped_fields_field {
    import WrappedRecord = ns_tables_data_records_wrapped_record.WrappedRecord;

    class WrappedRecordField {
        #private;

        get assigned(): boolean;

        get value(): any;

        get unpublished(): boolean;

        set value(value: any);

        constructor(name: string, wrappedRecord: WrappedRecord);
    }
}

// FILE: tables/data/records/wrapped/fields/fields.d.ts
declare namespace ns_tables_data_records_wrapped_fields_fields {
    import WrappedRecord = ns_tables_data_records_wrapped_record.WrappedRecord;

    class WrappedRecordFields extends Map {
        constructor(wrappedRecord: WrappedRecord);
    }
}

// FILE: tables/data/records/wrapped/record.d.ts
declare namespace ns_tables_data_records_wrapped_record {
    import Product = ns_tables_data_factory_product.Product;
    import RecordData = ns_tables_data_records_data_record.RecordData;
    import RecordIdentifier = ns_tables_data_records_data_record.RecordIdentifier;
    import WrappedFactory = ns_tables_data_records_wrapped_factory.WrappedFactory;
    import WrappedRecordFields = ns_tables_data_records_wrapped_fields_fields.WrappedRecordFields;

    class WrappedRecord extends Product {
        #private;

        get identifier(): RecordIdentifier;

        get session(): string;

        get destroyed(): boolean;

        get record(): RecordData;

        get version(): number;

        get fields(): WrappedRecordFields;

        get loaded(): boolean;

        get fetched(): boolean;

        get fetching(): boolean;

        get found(): boolean;

        load: () => Promise<void>;
        fetch: () => Promise<void>;

        constructor(manager: WrappedFactory, key: string, instanceId: number, identifier: RecordIdentifier, session: string);

        destroy(): void;
    }
}

// FILE: tables/data/uuid.d.ts
declare namespace ns_tables_data_uuid {
    function createUUID(): string;
}

// FILE: tables/indices/index.d.ts
declare namespace ns_tables_indices_index {
    interface IndexSpecs {
        primary?: boolean;
        unique?: boolean;
        fields: string[];
        batches?: Record<string, string[]>;
    }

    /**
     * Index of the table
     */
    class Index {
        #private;

        get name(): string;

        get primary(): boolean;

        get unique(): boolean;

        get fields(): string[];

        get batches(): Record<string, string[]>;

        /**
         * Index Constructor
         *
         * @param name {string} The name of the index
         * @param specs {IndexSpecs} The index specification
         */
        constructor(name: string, specs: IndexSpecs);

        /**
         * Check if the index is suitable to be queried by the specified parameters
         *
         * @param {Record<string, string | number>} fields The fields to be used by the request
         * @param {string} action The action to be executed (tu, data, list, count)
         * @returns {boolean}
         */
        suitable(action: string, fields: Record<string, any>): boolean;
    }
}

// FILE: tables/indices/indices.d.ts
declare namespace ns_tables_indices_indices {
    import Index = ns_tables_indices_index.Index;
    import IndexSpecs = ns_tables_indices_index.IndexSpecs;
    import Table = ns_tables_table.Table;
    type IndicesSpecs = Record<string, IndexSpecs>;

    /**
     * The indices collection
     */
    class Indices extends Map<string, Index> {
        #private;

        get primary(): Index;

        /**
         * Indices collection Constructor
         * @param table {object} The table that contains the indices
         * @param specs {object} The indices specification
         */
        constructor(table: Table, specs: IndicesSpecs);

        /**
         * Select an index to be used to query by the specified fields
         *
         * @param {string} action The action (data, list, count)
         * @param {Record<string, any>} fields The fields of the request
         * @returns {Index | undefined}
         */
        select(action: string, fields: Record<string, any>): Index | undefined;
    }
}

// FILE: tables/local-database/counters/counters.d.ts
declare namespace ns_tables_localdatabase_counters_counters {
    import LocalDB = ns_tables_localdatabase_localdatabase.LocalDB;
    import MemoryLocalDBCounters = ns_tables_localdatabase_counters_memory.MemoryLocalDBCounters;
    import FilterSpecs = ns_tables_data_filter_filter.FilterSpecs;
    import CounterAttributes = ns_tables_data_counter_counter.CounterAttributes;
    type CounterStoreStructure = {
        key: string;
        value: number;
        savedTime: number;
    };

    class LocalDBCounters {
        #private;

        get memory(): MemoryLocalDBCounters;

        constructor(db: LocalDB);

        save(filter: FilterSpecs, attributes: CounterAttributes, data: number): Promise<boolean>;

        load(filter: FilterSpecs, attributes: CounterAttributes): Promise<number>;
    }
}

// FILE: tables/local-database/counters/memory.d.ts
declare namespace ns_tables_localdatabase_counters_memory {
    class MemoryLocalDBCounters extends Map<string, number> {
    }
}

// FILE: tables/local-database/lists/lists.d.ts
declare namespace ns_tables_localdatabase_lists_lists {
    import LocalDB = ns_tables_localdatabase_localdatabase.LocalDB;
    import MemoryLocalDBLists = ns_tables_localdatabase_lists_memory.MemoryLocalDBLists;
    import FilterSpecs = ns_tables_data_filter_filter.FilterSpecs;
    import ListAttributes = ns_tables_data_lists_list.ListAttributes;
    type IdsList = (string | number)[];
    type ListStoreStructure = {
        key: string;
        data: IdsList;
        savedTime: number;
    };

    class LocalDBLists {
        #private;

        get memory(): MemoryLocalDBLists;

        constructor(db: LocalDB);

        save(filter: FilterSpecs, attributes: ListAttributes, data: IdsList): Promise<boolean>;

        load(filter: FilterSpecs, attributes: ListAttributes): Promise<ListStoreStructure>;
    }
}

// FILE: tables/local-database/lists/memory.d.ts
declare namespace ns_tables_localdatabase_lists_memory {
    import ListStoreStructure = ns_tables_localdatabase_lists_lists.ListStoreStructure;

    class MemoryLocalDBLists extends Map<string, ListStoreStructure> {
    }
}

// FILE: tables/local-database/local-database.d.ts
declare namespace ns_tables_localdatabase_localdatabase {
    import Table = ns_tables_table.Table;
    import LocalDBRecords = ns_tables_localdatabase_records_records.LocalDBRecords;
    import LocalDBLists = ns_tables_localdatabase_lists_lists.LocalDBLists;
    import LocalDBUnpublished = ns_tables_localdatabase_records_unpublished.LocalDBUnpublished;
    import LocalDBCounters = ns_tables_localdatabase_counters_counters.LocalDBCounters;

    class LocalDB {
        #private;

        get table(): Table;

        get db(): IDBDatabase;

        get records(): LocalDBRecords;

        get unpublished(): LocalDBUnpublished;

        get lists(): LocalDBLists;

        get counters(): LocalDBCounters;

        get error(): boolean;

        prepare(): Promise<void>;

        constructor(table: Table);
    }
}

// FILE: tables/local-database/records/memory.d.ts
declare namespace ns_tables_localdatabase_records_memory {
    import RecordStoreStructure = ns_tables_localdatabase_records_records.RecordStoreStructure;
    import RecordData = ns_tables_data_records_data_record.RecordData;

    class MemoryLocalDBRecords extends Map<string, RecordStoreStructure> {
        generateKey: (pk: string | number, accessToken?: string) => string;

        exists(pk: string | number, accessToken: string): boolean;

        load(record: RecordData, accessToken?: string): RecordStoreStructure;

        save(pk: string | number, accessToken: string, value: RecordStoreStructure): void;

        remove(pk: string | number, accessToken: string): void;
    }
}

// FILE: tables/local-database/records/records.d.ts
declare namespace ns_tables_localdatabase_records_records {
    import LocalDB = ns_tables_localdatabase_localdatabase.LocalDB;
    import MemoryLocalDBRecords = ns_tables_localdatabase_records_memory.MemoryLocalDBRecords;
    type RecordFieldsValues = Record<string, any>;
    type IndexFieldsValues = Record<string, any>;
    type RecordStoreStructure = {
        data: RecordFieldsValues;
        version: number;
        accessToken?: string;
        savedTime: number;
    };

    class LocalDBRecords {
        #private;

        get memory(): MemoryLocalDBRecords;

        constructor(db: LocalDB);

        save(data: RecordFieldsValues, version: number, accessToken?: string): Promise<boolean>;

        remove(data: RecordFieldsValues, accessToken?: string): Promise<boolean>;

        load(indexName: string, fields: IndexFieldsValues, accessToken?: string): Promise<RecordStoreStructure>;
    }
}

// FILE: tables/local-database/records/unpublished.d.ts
declare namespace ns_tables_localdatabase_records_unpublished {
    import LocalDB = ns_tables_localdatabase_localdatabase.LocalDB;
    type RecordsValues = Record<string, any>;
    type UnpublishedRecordStoreStructure = {
        data: RecordsValues;
    };

    class LocalDBUnpublished {
        #private;

        constructor(db: LocalDB);

        save(localId: string, data: UnpublishedRecordStoreStructure): Promise<boolean>;

        load(localId: string): Promise<UnpublishedRecordStoreStructure>;
    }
}

// FILE: tables/properties/properties.d.ts
declare namespace ns_tables_properties_properties {
    import Property = ns_tables_properties_property.Property;
    import PropertySpecs = ns_tables_properties_property.PropertySpecs;
    import ItemPropertySpecs = ns_tables_properties_types_item.ItemPropertySpecs;
    import ItemsPropertySpecs = ns_tables_properties_types_items.ItemsPropertySpecs;
    import CollectionPropertySpecs = ns_tables_properties_types_collection.CollectionPropertySpecs;
    import ItemSelectorPropertySpecs = ns_tables_properties_types_itemselector.ItemSelectorPropertySpecs;
    import Table = ns_tables_table.Table;
    type PropertySpecsUnion = (PropertySpecs & (ItemPropertySpecs | ItemSelectorPropertySpecs | ItemsPropertySpecs | CollectionPropertySpecs));

    /**
     * The properties of the table / item
     */
    class Properties extends Map<string, Property> {
        #private;

        get table(): Table;

        /**
         * Properties constructor
         * @param table {Table} The table
         * @param specs {object} The properties specification
         */
        constructor(table: Table, specs: Record<string, PropertySpecsUnion>);

        register(name: string, specs: PropertySpecsUnion): this;

        validate(): boolean;
    }
}

// FILE: tables/properties/property.d.ts
declare namespace ns_tables_properties_property {
    import Table = ns_tables_table.Table;

    interface PropertySpecs {
        readonly?: boolean;
        immutable?: boolean;
    }

    interface Property {
        type: string;
    }

    /**
     * A property of the table / item
     */
    abstract class Property {
        #private;

        get parentTable(): Table;

        get specs(): PropertySpecs;

        get name(): string;

        get readonly(): boolean;

        get immutable(): boolean;

        abstract validate(): boolean;

        /**
         * Property constructor
         *
         * @param {Table} parentTable The table where the property resides
         * @param {string} name The property name
         * @param {PropertySpecs} specs The property specification
         */
        protected constructor(parentTable: Table, name: string, specs: PropertySpecs);
    }
}

// FILE: tables/properties/types/collection.d.ts
declare namespace ns_tables_properties_types_collection {
    import DerivedCollection = ns_elements_collection_collection.DerivedCollection;
    import PropertySpecs = ns_tables_properties_property.PropertySpecs;
    import Property = ns_tables_properties_property.Property;
    import Item = ns_elements_item_item.Item;
    import Table = ns_tables_table.Table;

    interface FieldFilterSpec {
        field: string;
        source?: string;
        value?: string | boolean | number;
        transform?: (item: Item, value: any) => any;
    }

    type FilterSpec = FieldFilterSpec[];

    interface CollectionPropertySpecs {
        Collection: DerivedCollection;
        filter: FilterSpec;
        table: string;
    }

    class CollectionProperty extends Property {
        #private;

        get type(): string;

        get table(): string;

        get Collection(): DerivedCollection;

        get filterSpec(): FilterSpec;

        constructor(parentTable: Table, name: string, specs: PropertySpecs & CollectionPropertySpecs);

        validate(): boolean;
    }
}

// FILE: tables/properties/types/item-selector.d.ts
declare namespace ns_tables_properties_types_itemselector {
    import PropertySpecs = ns_tables_properties_property.PropertySpecs;
    import Property = ns_tables_properties_property.Property;
    import DerivedItem = ns_elements_item_item.DerivedItem;
    import Item = ns_elements_item_item.Item;
    import RecordIdentifier = ns_tables_data_records_data_record.RecordIdentifier;
    import Table = ns_tables_table.Table;

    interface ItemSelectorResponse {
        table: string;
        Item: DerivedItem;
        identifier: RecordIdentifier;
    }

    interface ItemSelectorPropertySpecs {
        selector: (item: Item) => ItemSelectorResponse;
        tables: string[];
    }

    class ItemSelectorProperty extends Property {
        #private;

        get type(): string;

        get selector(): (item: Item) => ItemSelectorResponse;

        get tables(): string[];

        constructor(parentTable: Table, name: string, specs: PropertySpecs & ItemSelectorPropertySpecs);

        validate(): boolean;
    }
}

// FILE: tables/properties/types/item.d.ts
declare namespace ns_tables_properties_types_item {
    import DerivedItem = ns_elements_item_item.DerivedItem;
    import Item = ns_elements_item_item.Item;
    import PropertySpecs = ns_tables_properties_property.PropertySpecs;
    import Property = ns_tables_properties_property.Property;
    import Table = ns_tables_table.Table;

    interface FieldIdentifierSpec {
        field: string;
        source?: string;
        value?: string;
        transform?: (item: Item, value: any) => any;
    }

    type IdentifierSpec = FieldIdentifierSpec[];

    interface ItemPropertySpecs {
        Item: DerivedItem;
        identifier: IdentifierSpec;
        table: string;
    }

    class ItemProperty extends Property {
        #private;

        get type(): string;

        get table(): string;

        get Item(): DerivedItem;

        get identifierSpec(): IdentifierSpec;

        constructor(parentTable: Table, name: string, specs: PropertySpecs & ItemPropertySpecs);

        validate(): boolean;
    }
}

// FILE: tables/properties/types/items.d.ts
declare namespace ns_tables_properties_types_items {
    import DerivedItem = ns_elements_item_item.DerivedItem;
    import PropertySpecs = ns_tables_properties_property.PropertySpecs;
    import Property = ns_tables_properties_property.Property;
    import Table = ns_tables_table.Table;

    interface ItemsPropertyIdentifierSpecs {
        field: string;
        source: string;
    }

    interface ItemsPropertySpecs {
        Items: DerivedItem;
        identifier: ItemsPropertyIdentifierSpecs;
        table: string;
    }

    class ItemsProperty extends Property {
        #private;

        get type(): string;

        get table(): string;

        get Items(): DerivedItem;

        get identifier(): ItemsPropertyIdentifierSpecs;

        constructor(parentTable: Table, name: string, specs: PropertySpecs & ItemsPropertySpecs);

        validate(): boolean;
    }
}

// FILE: tables/queries/batch/batch.d.ts
declare namespace ns_tables_queries_batch_batch {
    import Module = dependency_0.Module;

    interface BatchSpecs {
        module: Module;
        action: string;
        max?: number;
    }

    class Batch<REQUEST, RESPONSE> {
        #private;

        get queueLength(): number;

        /**
         * Batch constructor
         * @param {BatchSpecs} specs
         */
        constructor(specs: BatchSpecs);

        /**
         * Push a new request
         *
         * @param {REQUEST} value
         * @returns {Promise<RESPONSE>}
         */
        exec(value: REQUEST): Promise<RESPONSE>;
    }
}

// FILE: tables/queries/batch/request.d.ts
declare namespace ns_tables_queries_batch_request {
    import PendingPromise = dependency_0.PendingPromise;

    class BatchRequest<RESPONSE> {
        #private;

        get id(): string;

        get value(): any;

        get promise(): PendingPromise<RESPONSE>;

        constructor(value: any);
    }
}

// FILE: tables/queries/counter.d.ts
declare namespace ns_tables_queries_counter {
    import FilterSpecs = ns_tables_data_filter_filter.FilterSpecs;
    import CounterAttributes = ns_tables_data_counter_counter.CounterAttributes;
    import Table = ns_tables_table.Table;

    class CounterQuery {
        #private;

        constructor(table: Table);

        exec(filter: FilterSpecs, attributes: CounterAttributes): Promise<number>;
    }
}

// FILE: tables/queries/data.d.ts
declare namespace ns_tables_queries_data {
    import ListAttributes = ns_tables_data_lists_list.ListAttributes;
    import RecordStoreStructure = ns_tables_localdatabase_records_records.RecordStoreStructure;
    import Table = ns_tables_table.Table;
    type DataQueryFields = Record<string, any>;

    class DataQuery {
        #private;

        constructor(table: Table);

        exec(fields: DataQueryFields, attributes: ListAttributes): Promise<RecordStoreStructure>;
    }
}

// FILE: tables/queries/list.d.ts
declare namespace ns_tables_queries_list {
    import FilterSpecs = ns_tables_data_filter_filter.FilterSpecs;
    import ListAttributes = ns_tables_data_lists_list.ListAttributes;
    import Table = ns_tables_table.Table;
    type QueryRecordResponse = Record<string, any>;

    interface ListQueryRecordResponse {
        uptodate: boolean;
        pk?: string;
        version?: number;
        data?: QueryRecordResponse;
    }

    class ListQuery {
        #private;

        constructor(table: Table);

        /**
         * Executes a list query
         *
         * @param {FilterSpecs} filter
         * @param {ListAttributes} attributes
         * @returns {Promise<(string | number)[]>}
         */
        exec(filter: FilterSpecs, attributes: ListAttributes): Promise<(string | number)[]>;
    }
}

// FILE: tables/queries/queries.d.ts
declare namespace ns_tables_queries_queries {
    import Table = ns_tables_table.Table;
    import FilterSpecs = ns_tables_data_filter_filter.FilterSpecs;
    import ListAttributes = ns_tables_data_lists_list.ListAttributes;
    import RecordStoreStructure = ns_tables_localdatabase_records_records.RecordStoreStructure;
    import CounterAttributes = ns_tables_data_counter_counter.CounterAttributes;
    import DataQueryFields = ns_tables_queries_data.DataQueryFields;

    class Queries {
        #private;

        constructor(table: Table);

        data(fields: DataQueryFields, attributes: ListAttributes): Promise<RecordStoreStructure>;

        list(filter: FilterSpecs, attributes: ListAttributes): Promise<(string | number)[]>;

        counter(filter: FilterSpecs, attributes: CounterAttributes): Promise<number>;
    }
}

// FILE: tables/table.d.ts
declare namespace ns_tables_table {
    import Properties = ns_tables_properties_properties.Properties;
    import PropertySpecsUnion = ns_tables_properties_properties.PropertySpecsUnion;
    import Indices = ns_tables_indices_indices.Indices;
    import IndicesSpecs = ns_tables_indices_indices.IndicesSpecs;
    import LocalDB = ns_tables_localdatabase_localdatabase.LocalDB;
    import Queries = ns_tables_queries_queries.Queries;
    import Module = dependency_0.Module;
    import ListsManager = ns_tables_data_lists_manager_manager.ListsManager;
    import RecordsManager = ns_tables_data_records_manager.RecordsManager;
    import CountersManager = ns_tables_data_counter_manager.CountersManager;

    interface CacheSpecs {
        enabled: boolean;
        limit?: number;
    }

    interface TableBatchConfig {
        actions: {
            data: string;
            list: string;
            count?: string;
        };
        max?: number;
    }

    interface TableSpecs {
        cache: CacheSpecs | undefined | boolean;
        module: Module;
        version?: number;
        batch: TableBatchConfig;
        indices: IndicesSpecs;
        fields: string[];
        properties?: Record<string, PropertySpecsUnion>;
    }

    /**
     * Table data access
     *
     * @param name {string} The table name
     * @param specs {object} The table specification
     * @constructor
     */
    class Table {
        #private;

        get name(): string;

        get version(): number;

        get cache(): CacheSpecs;

        get module(): Module;

        get batch(): TableBatchConfig;

        get fields(): string[];

        get properties(): Properties;

        get indices(): Indices;

        get localDB(): LocalDB;

        get records(): RecordsManager;

        get lists(): ListsManager;

        get counters(): CountersManager;

        get queries(): Queries;

        constructor(name: string, specs: TableSpecs);

        validate(): boolean;
    }
}

// FILE: tables/tables.d.ts
declare namespace ns_tables_tables {
    import Table = ns_tables_table.Table;
    import TableSpecs = ns_tables_table.TableSpecs;

    class Tables extends Map<string, Table> {
        register(name: string, specs: TableSpecs): Table;

        validate(): boolean;
    }

    const tables: Tables;
}

// FILE: tree/collection.d.ts
declare namespace ns_tree_collection {
    import NodeSpecs = ns_tree_specs.NodeSpecs;
    import Node = ns_tree_node.Node;
    import ItemNode = ns_tree_item.ItemNode;
    import NodesSpecs = ns_tree_specs.NodesSpecs;
    import Property = ns_tables_properties_property.Property;
    import OrderSpecs = ns_tables_data_lists_order.OrderSpecs;

    interface ICollectionNodeSpecs extends NodeSpecs {
        view?: string;
        limit?: number;
        properties?: NodesSpecs;
        order?: OrderSpecs;
        counters?: string[];
    }

    class CollectionNode extends Node {
        #private;

        get is(): string;

        get view(): string;

        get limit(): number;

        get items(): ItemNode;

        get order(): OrderSpecs;

        get counters(): Set<string>;

        constructor(table: string, specs: ICollectionNodeSpecs, parent?: Node, property?: Property);
    }
}

// FILE: tree/item-selector.d.ts
declare namespace ns_tree_itemselector {
    import Node = ns_tree_node.Node;
    import ItemSelectorProperty = ns_tables_properties_types_itemselector.ItemSelectorProperty;
    import Property = ns_tables_properties_property.Property;
    import NodesSpecs = ns_tree_specs.NodesSpecs;
    import ItemNode = ns_tree_item.ItemNode;

    interface ItemSelectorNodeSpecs {
        [table: string]: NodesSpecs;
    }

    class ItemSelectorNode extends Node {
        #private;

        get is(): string;

        get tables(): Map<string, ItemNode>;

        get property(): Property;

        constructor(table: string, specs?: ItemSelectorNodeSpecs, parent?: Node, property?: ItemSelectorProperty);
    }
}

// FILE: tree/item.d.ts
declare namespace ns_tree_item {
    import NodeSpecs = ns_tree_specs.NodeSpecs;
    import Node = ns_tree_node.Node;
    import Properties = ns_tree_properties.Properties;
    import NodesSpecs = ns_tree_specs.NodesSpecs;
    import ItemProperty = ns_tables_properties_types_item.ItemProperty;
    import ItemsProperty = ns_tables_properties_types_items.ItemsProperty;
    import ItemSelectorProperty = ns_tables_properties_types_itemselector.ItemSelectorProperty;

    interface ItemNodeSpecs extends NodeSpecs {
        properties?: NodesSpecs;
    }

    class ItemNode extends Node {
        #private;

        get is(): string;

        get specs(): ItemNodeSpecs;

        get properties(): Properties;

        constructor(table: string, specs?: ItemNodeSpecs, parent?: Node, property?: ItemProperty | ItemsProperty | ItemSelectorProperty);
    }
}

// FILE: tree/items.d.ts
declare namespace ns_tree_items {
    import Node = ns_tree_node.Node;
    import NodesSpecs = ns_tree_specs.NodesSpecs;
    import NodeSpecs = ns_tree_specs.NodeSpecs;
    import ItemNode = ns_tree_item.ItemNode;
    import ItemsProperty = ns_tables_properties_types_items.ItemsProperty;

    interface ItemsNodeSpecs extends NodeSpecs {
        properties: NodesSpecs;
    }

    class ItemsNode extends Node {
        #private;

        get is(): string;

        get items(): ItemNode;

        constructor(table: string, specs?: ItemsNodeSpecs, parent?: Node, property?: ItemsProperty);
    }
}

// FILE: tree/node.d.ts
declare namespace ns_tree_node {
    import Events = dependency_0.Events;
    import NodeSpecs = ns_tree_specs.NodeSpecs;
    import Table = ns_tables_table.Table;
    import Property = ns_tables_properties_property.Property;

    class Node extends Events {
        #private;

        get property(): Property;

        get table(): Table;

        get session(): string;

        get root(): Node;

        get parent(): Node;

        get active(): boolean;
        set active(value: boolean);

        /**
         * The Node Constructor
         * @param {string} table The table name
         * @param {NodeSpecs} specs The node specification
         * @param {Node} parent The parent node in the tree
         * @param {Property} property The table property.
         * Undefined when the node is created from the item or the collection instead of being created by the tree
         */
        constructor(table: string, specs?: NodeSpecs, parent?: Node, property?: Property);

        trigger(event: string, ...rest: any): any;
    }
}

// FILE: tree/properties.d.ts
declare namespace ns_tree_properties {
    import NodesSpecs = ns_tree_specs.NodesSpecs;
    import Table = ns_tables_table.Table;
    import Node = ns_tree_node.Node;
    import ItemNode = ns_tree_item.ItemNode;
    import CollectionNode = ns_tree_collection.CollectionNode;
    import ItemsNode = ns_tree_items.ItemsNode;
    import ItemSelectorNode = ns_tree_itemselector.ItemSelectorNode;
    type NodeTypes = ItemSelectorNode | ItemNode | CollectionNode | ItemsNode;

    class Properties extends Map<string, NodeTypes> {
        #private;

        constructor(table: Table);

        register(properties: NodesSpecs | undefined, parent: Node): void;
    }
}

// FILE: tree/specs.d.ts
declare namespace ns_tree_specs {
    import ItemNodeSpecs = ns_tree_item.ItemNodeSpecs;
    import ICollectionNodeSpecs = ns_tree_collection.ICollectionNodeSpecs;
    import ItemsNodeSpecs = ns_tree_items.ItemsNodeSpecs;
    import ItemSelectorNodeSpecs = ns_tree_itemselector.ItemSelectorNodeSpecs;
    type NodesSpecs = Record<string, boolean | ItemNodeSpecs | ICollectionNodeSpecs | ItemsNodeSpecs | ItemSelectorNodeSpecs>;

    interface NodeSpecs {
        session?: string;
    }
}

export import auth = ns_auth_auth.auth;
export import NotSet = ns_constants.NotSet;
export import DataSource = ns_constants.DataSource;
export import CollectionSpecs = ns_elements_collection_collection.CollectionSpecs;
export import Collection = ns_elements_collection_collection.Collection;
export import ItemSpecs = ns_elements_item_item.ItemSpecs;
export import Item = ns_elements_item_item.Item;
export import CollectionProperty = ns_elements_item_properties_collection_property.CollectionProperty;
export import ItemSelectorProperty = ns_elements_item_properties_itemselector_property.ItemSelectorProperty;
export import ItemProperty = ns_elements_item_properties_item_property.ItemProperty;
export import ItemsProperty = ns_elements_item_properties_items_property.ItemsProperty;
export import ConditionOperand = ns_tables_data_filter_filter.ConditionOperand;
export import realtime = ns_tables_data_realtime_realtime.realtime;
export import ListUpdateFilterReport = ns_tables_data_realtime_reports_list.ListUpdateFilterReport;
export import RecordUpdateFilterReport = ns_tables_data_realtime_reports_record.RecordUpdateFilterReport;
export import TableSpecs = ns_tables_table.TableSpecs;
export import tables = ns_tables_tables.tables;


export declare const hmr: { on: (event: string, listener: any) => void, off: (event: string, listener: any) => void };