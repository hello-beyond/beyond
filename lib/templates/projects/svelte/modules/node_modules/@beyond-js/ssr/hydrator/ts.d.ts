/************
Processor: ts
************/

import * as dependency_0 from '@beyond-js/kernel/routing/ts';
import * as dependency_1 from '@beyond-js/kernel/core/ts';

// FILE: base\package.d.ts
declare namespace ns_base_package {
    /**
     * Resolve the id of a module considering relatives paths to the source that is requiring it
     *
     * @param source {string} The module from where the require is being requested
     * @param id {string} The module being requested
     * @returns {string} The module processed with relative paths
     */
    function resolve(source: string, id: string): string;
    /**
     * This class is used only by beyond/core
     */
    class BeyondPackage {
        #private;
        constructor(exports: any);
        initialise(ims?: Map<string, any>): void;
        /**
         * Solve the require function
         *
         * @param source {string} The module from where the require is being triggered
         * @param id {string} The module id being requested
         * @returns {*}
         */
        require(id: string, source?: string): any;
    }
}

// FILE: config.d.ts
declare namespace ns_config {
    interface IWidgetRendered {
        html?: string;
        errors?: string[];
        css?: string;
        store: object;
    }
    const config: {
        readonly "__#70613@#hierarchy": string[];
        readonly hierarchy: string[];
        readonly "__#70613@#widgets": Map<number, IWidgetRendered>;
        readonly widgets: Map<number, IWidgetRendered>;
    };
}

// FILE: hydrator.d.ts
declare namespace ns_hydrator { }

// FILE: widgets\layout-children.d.ts
declare namespace ns_widgets_layoutchildren {
    import BeyondLayoutChildrenRenderer = dependency_0.BeyondLayoutChildrenRenderer;
    interface IBeyondLayoutChildrenRenderer {
        new (component: HTMLElement): BeyondLayoutChildrenRenderer;
    }
    const instances: {
        "__#70615@#BeyondLayoutChildrenRenderer": IBeyondLayoutChildrenRenderer;
        "__#70615@#instances": Set<BeyondLayoutChildren>;
        register(instance: BeyondLayoutChildren): void;
        hydrate(BeyondLayoutChildrenRenderer: IBeyondLayoutChildrenRenderer): void;
    };
    class BeyondLayoutChildren extends HTMLElement {
        #private;
        constructor();
        connectedCallback(): void;
        hydrate(Renderer: IBeyondLayoutChildrenRenderer): void;
    }
}

// FILE: widgets\widget.d.ts
declare namespace ns_widgets_widget {
    import WidgetControllerLoader = dependency_1.WidgetControllerLoader;
    interface IWidgetControllerLoader {
        new (component: HTMLElement): WidgetControllerLoader;
    }
    class Widget extends HTMLElement {
        #private;
        constructor(id: number);
        hydrate(WidgetControllerLoader: IWidgetControllerLoader): void;
        connectedCallback(): void;
    }
}

// FILE: widgets\widgets.d.ts
declare namespace ns_widgets_widgets {
    import BeyondLayoutChildrenRenderer = dependency_0.BeyondLayoutChildrenRenderer;
    import IWidgetControllerLoader = ns_widgets_widget.IWidgetControllerLoader;
    import Widget = ns_widgets_widget.Widget;
    const widgets: {
        "__#70617@#WidgetControllerLoader": IWidgetControllerLoader;
        "__#70617@#instances": Set<Widget>;
        "__#70617@#initialised": boolean;
        "__#70617@#roots": Map<Node, Widget>;
        readonly roots: Map<Node, Widget>;
        registerInstance(instance: Widget): void;
        hydrate(WidgetControllerLoader: IWidgetControllerLoader, BeyondLayoutChildrenRenderer: BeyondLayoutChildrenRenderer): void;
    };
}



export declare const hmr: {on: (event: string, listener: any) => void, off: (event: string, listener: any) => void };